---
layout:     post
title:      微信公众号开发者模式搭建
subtitle:   公众号平台对接
date:       2017-12-18
author:     lulongji
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - 微信公众号
    - java
---

# 准备工作

### 注册
首先在微信公众平台```https://mp.weixin.qq.com``` 创建自己的账号密码

### 对接API
登陆之后找到开发者工具找到公众平台测试账号，以下是要进行服务对接的必要条件
![微信](https://raw.githubusercontent.com/lulongji/lulongji.github.io/master/imgs/wechat/weixin1.png)
![微信](https://raw.githubusercontent.com/lulongji/lulongji.github.io/master/imgs/wechat/weixin2.png)
![微信](https://raw.githubusercontent.com/lulongji/lulongji.github.io/master/imgs/wechat/weixin3.png)
![微信](https://raw.githubusercontent.com/lulongji/lulongji.github.io/master/imgs/wechat/weixin4.png)

# 基础代码

### 基础Message

####  图文
    public class Article {
        // 图文消息名称
        private String Title;
        // 图文消息描述
        private String Description;
        // 图片链接，支持JPG、PNG格式，较好的效果为大图640*320，小图80*80，限制图片链接的域名需要与开发者填写的基本资料中的Url一致
        private String PicUrl;
        // 点击图文消息跳转链接
        private String Url;
    }
#### 消息基类（公众帐号 -> 普通用户）
    public class BaseMessage {
        // 接收方帐号（收到的OpenID）
        private String ToUserName;
        // 开发者微信号
        private String FromUserName;
        // 消息创建时间 （整型）
        private long CreateTime;
        // 消息类型（text/music/news）
        private String MsgType;
        // 位0x0001被标志时，星标刚收到的消息
        private int FuncFlag;
    }
#### 音乐model
    public class Music {
        // 音乐名称
        private String Title;
        // 音乐描述
        private String Description;
        // 音乐链接
        private String MusicUrl;
        // 高质量音乐链接，WIFI环境优先使用该链接播放音乐
        private String HQMusicUrl;
    }
#### 音乐消息
    public class MusicMessage extends BaseMessage {
        // 音乐
        private Music Music;
    }

#### 文本消息
    public class NewsMessage extends BaseMessage {
        // 图文消息个数，限制为10条以内
        private int ArticleCount;
        // 多条图文消息信息，默认第一个item为大图
        private List<Article> Articles;
    }

#### 文本消息
    public class TextMessage extends BaseMessage {
        // 回复的消息内容
        private String Content;
    }

### 基础Utils

#### 发送https请求

        /**
        * 发送https请求
        *
        * @param requestUrl    请求地址
        * @param requestMethod 请求方式（GET、POST）
        * @param outputStr     提交的数据
        * @return JSONObject(通过JSONObject.get(key)的方式获取json对象的属性值)
        */
        public static JSONObject httpsRequest(String requestUrl, String requestMethod, String outputStr) {
            JSONObject jsonObject = null;
            try {
                // 创建SSLContext对象，并使用我们指定的信任管理器初始化
                TrustManager[] tm = {new MyX509TrustManager()};
                SSLContext sslContext = SSLContext.getInstance("SSL", "SunJSSE");
                sslContext.init(null, tm, new java.security.SecureRandom());
                // 从上述SSLContext对象中得到SSLSocketFactory对象
                SSLSocketFactory ssf = sslContext.getSocketFactory();

                URL url = new URL(requestUrl);
                HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
                conn.setSSLSocketFactory(ssf);

                conn.setDoOutput(true);
                conn.setDoInput(true);
                conn.setUseCaches(false);
                // 设置请求方式（GET/POST）
                conn.setRequestMethod(requestMethod);

                // 当outputStr不为null时向输出流写数据
                if (null != outputStr) {
                    OutputStream outputStream = conn.getOutputStream();
                    // 注意编码格式
                    outputStream.write(outputStr.getBytes("UTF-8"));
                    outputStream.close();
                }

                // 从输入流读取返回内容
                InputStream inputStream = conn.getInputStream();
                InputStreamReader inputStreamReader = new InputStreamReader(inputStream, "utf-8");
                BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
                String str = null;
                StringBuffer buffer = new StringBuffer();
                while ((str = bufferedReader.readLine()) != null) {
                    buffer.append(str);
                }

                // 释放资源
                bufferedReader.close();
                inputStreamReader.close();
                inputStream.close();
                inputStream = null;
                conn.disconnect();
                jsonObject = JSONObject.parseObject(buffer.toString());
            } catch (ConnectException ce) {
                logger.error("连接超时：{}", ce);
            } catch (Exception e) {
                logger.error("https请求异常：{}", e);
            }
            return jsonObject;
        }

#### 消息工具类

    public class MessageUtil {

        /**
        * 返回消息类型：文本
        */
        public static final String RESP_MESSAGE_TYPE_TEXT = "text";

        /**
        * 返回消息类型：音乐
        */
        public static final String RESP_MESSAGE_TYPE_MUSIC = "music";

        /**
        * 返回消息类型：图文
        */
        public static final String RESP_MESSAGE_TYPE_NEWS = "news";


        /**
        * 请求消息类型：文本
        */
        public static final String REQ_MESSAGE_TYPE_TEXT = "text";

        /**
        * 请求消息类型：图片
        */
        public static final String REQ_MESSAGE_TYPE_IMAGE = "image";

        /**
        * 请求消息类型：链接
        */
        public static final String REQ_MESSAGE_TYPE_LINK = "link";

        /**
        * 请求消息类型：地理位置
        */
        public static final String REQ_MESSAGE_TYPE_LOCATION = "location";

        /**
        * 请求消息类型：音频
        */
        public static final String REQ_MESSAGE_TYPE_VOICE = "voice";

        /**
        * 请求消息类型：推送
        */
        public static final String REQ_MESSAGE_TYPE_EVENT = "event";


        /**
        * 事件类型：subscribe(订阅)
        */
        public static final String EVENT_TYPE_SUBSCRIBE = "subscribe";

        /**
        * 事件类型：unsubscribe(取消订阅)
        */
        public static final String EVENT_TYPE_UNSUBSCRIBE = "unsubscribe";

        /**
        * 事件类型：CLICK(自定义菜单点击事件)
        */
        public static final String EVENT_TYPE_CLICK = "CLICK";

        /**
        * 解析微信发来的请求（XML）
        *
        * @param request
        * @return
        * @throws Exception
        */
        @SuppressWarnings("unchecked")
        public static Map<String, String> parseXml(HttpServletRequest request) throws Exception {

            BufferedReader reader = null;
            reader = request.getReader();
            String line = null;
            String xmlString = null;
            StringBuffer inputString = new StringBuffer();

            while ((line = reader.readLine()) != null) {
                inputString.append(line);
            }
            xmlString = inputString.toString();
            request.getReader().close();
            System.out.println("接收到的数据如下--->" + xmlString);
            return XmlUtil.doXMLParse(xmlString);
        }

        /**
        * 文本消息对象转换成xml
        *
        * @param textMessage 文本消息对象
        * @return xml
        */
        public static String textMessageToXml(TextMessage textMessage) {
            xstream.alias("xml", textMessage.getClass());
            return xstream.toXML(textMessage);
        }

        /**
        * 音乐消息对象转换成xml
        *
        * @param musicMessage 音乐消息对象
        * @return xml
        */
        public static String musicMessageToXml(MusicMessage musicMessage) {
            xstream.alias("xml", musicMessage.getClass());
            return xstream.toXML(musicMessage);
        }

        /**
        * 图文消息对象转换成xml
        *
        * @param newsMessage 图文消息对象
        * @return xml
        */
        public static String newsMessageToXml(NewsMessage newsMessage) {
            xstream.alias("xml", newsMessage.getClass());
            xstream.alias("item", new Article().getClass());
            return xstream.toXML(newsMessage);
        }

        /**
        * 扩展xstream，使其支持CDATA块
        *
        * @date 2013-05-19
        */
        private static XStream xstream = new XStream(new XppDriver() {
            public HierarchicalStreamWriter createWriter(Writer out) {
                return new PrettyPrintWriter(out) {
                    // 对所有xml节点的转换都增加CDATA标记
                    boolean cdata = true;

                    public void startNode(String name, @SuppressWarnings("rawtypes") Class clazz) {
                        super.startNode(name);
                    }

                    protected void writeText(QuickWriter writer, String text) {
                        if (cdata) {
                            writer.write("<![CDATA[");
                            writer.write(text);
                            writer.write("]]>");
                        } else {
                            writer.write(text);
                        }
                    }
                };
            }
        });
    }

#### 信任管理器
    public class MyX509TrustManager implements X509TrustManager {

        // 检查客户端证书
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        // 检查服务器端证书
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        // 返回受信任的X509证书数组
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }
    }
#### 请求校验
    public class SignUtil {

        /**
        * 验证签名
        *
        * @param signature
        * @param timestamp
        * @param nonce
        * @return
        */
        public static boolean checkSignature(String signature, String timestamp, String nonce, String token) {
            String[] arr = new String[]{token, timestamp, nonce};
            // 将token、timestamp、nonce三个参数进行字典序排序
            Arrays.sort(arr);
            StringBuilder content = new StringBuilder();
            for (int i = 0; i < arr.length; i++) {
                content.append(arr[i]);
            }
            MessageDigest md = null;
            String tmpStr = null;

            try {
                md = MessageDigest.getInstance("SHA-1");
                // 将三个参数字符串拼接成一个字符串进行sha1加密
                byte[] digest = md.digest(content.toString().getBytes());
                tmpStr = byteToStr(digest);
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }

            content = null;
            // 将sha1加密后的字符串可与signature对比，标识该请求来源于微信
            return tmpStr != null ? tmpStr.equals(signature.toUpperCase()) : false;
        }

        /**
        * 将字节数组转换为十六进制字符串
        *
        * @param byteArray
        * @return
        */
        private static String byteToStr(byte[] byteArray) {
            String strDigest = "";
            for (int i = 0; i < byteArray.length; i++) {
                strDigest += byteToHexStr(byteArray[i]);
            }
            return strDigest;
        }

        /**
        * 将字节转换为十六进制字符串
        *
        * @param mByte
        * @return
        */
        private static String byteToHexStr(byte mByte) {
            char[] Digit = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
            char[] tempArr = new char[2];
            tempArr[0] = Digit[(mByte >>> 4) & 0X0F];
            tempArr[1] = Digit[mByte & 0X0F];

            String s = new String(tempArr);
            return s;
        }
    }
